{"ast":null,"code":"var _jsxFileName = \"C:\\\\wamp64\\\\www\\\\Projet_TER\\\\src\\\\views\\\\Quiz.js\";\nimport React from 'react';\nimport axios from 'axios';\nimport Issues from '../components/quiz/issues';\nimport Historic from '../components/quiz/historic';\nimport Method from '../components/quiz/method';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport class Quiz extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.changeData = (nextIssueId, decision = null, allChoices = null, historic = true, editHistoric = false) => {\n      // ID de la prochaine question\n      this.setState({\n        checkedDecision: decision\n      });\n      console.log(this.state.tree); //  Vérifie si la décision renvoie une méthode\n\n      let method = this.checkMethod(decision);\n\n      if (method) {\n        this.manageMethod(decision, method);\n      } else {\n        // si ID prochaine question pas égal a 0 on récupère info\n        if (nextIssueId != 0) {\n          if (allChoices) {\n            // si on est sur le critère de fin et qu'on continue, on reinitialise l'historique\n            let restart;\n            allChoices.forEach(element => {\n              let decision = this.state.tree.decisions.find(el => el.ID_Decision === element);\n\n              if (decision.ID_Critere_sortant === null) {\n                restart = true;\n              }\n            });\n            console.log(restart);\n\n            if (restart) {\n              this.setState({\n                historic: [],\n                step: 0\n              }, () => {\n                this.manageStoreData(nextIssueId, decision, historic, editHistoric);\n              });\n            } else {\n              this.manageStoreData(nextIssueId, decision, historic, editHistoric);\n            }\n          } else {\n            this.manageStoreData(nextIssueId, decision, historic, editHistoric);\n          }\n        } else {\n          alert(\"fini\");\n        }\n      }\n    };\n\n    this.manageStoreData = (nextIssueId, decision, historic, editHistoric) => {\n      // on va chercher la prochaine question et réponses\n      let issue = this.state.tree.criteres.find(critere => critere.ID_Critere === nextIssueId);\n      let decisions = this.state.tree.decisions.filter(decision => decision.ID_Critere_entrant === issue.ID_Critere);\n      let oldIssue = this.state.currentIssue;\n      this.setState({\n        currentIssue: issue,\n        currentDecisions: decisions,\n        step: this.state.step + 1\n      }, () => {\n        // on met a jour l'historique\n        if (historic) {\n          this.manageHistoric(decision, oldIssue);\n        }\n\n        if (editHistoric) {\n          let historicElement = {\n            issue: this.state.currentIssue,\n            decision: null\n          };\n          this.setState({\n            historic: this.state.historic.concat(historicElement)\n          });\n        }\n      });\n    };\n\n    this.manageMethod = (decision, method) => {\n      this.state.historic[this.state.historic.length - 1].decision = decision;\n      let historicElement = {\n        method: method\n      };\n      this.setState({\n        historic: this.state.historic.concat(historicElement)\n      });\n    };\n\n    this.checkMethod = decision => {\n      if (decision) {\n        let method = this.state.tree.methodes.find(methode => methode.ID_Decision === decision.ID_Decision);\n\n        if (method) {\n          this.setState({\n            currentMethod: method\n          });\n          return method;\n        }\n      }\n    };\n\n    this.backOut = (ID, type) => {\n      // si on retroune a une question\n      if (type == 'issue') {\n        // si au moment ou on retourne on est sur une méthode\n        if (this.state.currentMethod) {\n          this.setState({\n            currentMethod: null\n          }, () => {\n            this.backIssue(ID);\n          });\n        } else {\n          this.backIssue(ID);\n        }\n      } else {\n        // si on retourne a une méthode\n        let index = this.state.historic.indexOf(this.state.historic.find(el => el.method));\n        let method = this.state.historic[index].method;\n        let decisionBeforeMethod = this.state.historic[index - 1].decision;\n        this.state.historic.length = index;\n        this.setState({\n          step: index\n        });\n        this.changeData(decisionBeforeMethod.ID_Critere_sortant, decisionBeforeMethod, null, false);\n      }\n    };\n\n    this.backIssue = ID => {\n      let index;\n      this.changeData(ID, null, null, false);\n      this.state.historic.forEach(element => {\n        if ('issue' in element) {\n          if (element.issue.ID_Critere === ID) {\n            index = this.state.historic.indexOf(element);\n          }\n        }\n      }); // let index =  this.state.historic.indexOf(this.state.historic.find(el => el.issue.ID_Critere === ID));\n\n      this.state.historic.length = index + 1;\n      this.state.historic[index].decision = null;\n      this.setState({\n        step: index + 1\n      });\n    };\n\n    this.manageHistoric = (decision = null, oldIssue) => {\n      // si nous ne somme aps sur une méthode\n      // if(!this.state.currentMethod && this.state.historic){\n      // on ajoute la décision prise au critère précédent\n      this.state.historic.forEach(element => {\n        if ('issue' in element) {\n          if (element.issue.ID_Critere === oldIssue.ID_Critere) {\n            element.decision = decision;\n          }\n        }\n      }); // console.log(decision)\n      // console.log(oldIssue)\n      // let condition = this.state.historic.find(el => el.issue.ID_Critere === oldIssue.ID_Critere);\n      // if(condition){condition.decision = decision;}\n      // on ajoute le nouveau critère sans décision dans l'historique\n\n      let historicElement = {\n        issue: this.state.currentIssue,\n        decision: null\n      };\n      this.setState({\n        historic: this.state.historic.concat(historicElement)\n      }); //}  \n    };\n\n    this.resumeQuiz = () => {\n      this.setState({\n        currentMethod: null\n      }, () => {\n        this.changeData(this.state.checkedDecision.ID_Critere_sortant, null, null, false, true);\n      });\n    };\n\n    this.state = {\n      tree: null,\n      checkedDecision: null,\n      currentMethod: null,\n      currentIssue: null,\n      currentDecisions: [],\n      historic: [],\n      step: 0\n    }; // this.componentDidMount = this.componentDidMount.bind(this);\n  } // met a jour le questionnaire\n  // historic : met a jour l'historique normalement\n  // editHistoric : met a jour artificiellement quand on est sur une méthode (arret du flux)\n\n\n  componentDidMount() {\n    let protocol = window.location.protocol;\n    let host = window.location.hostname;\n    let url = protocol + '//' + host;\n\n    if (!this.state.tree) {\n      axios.get(url + '/reactTest/MATUI/API/Controllers/lireArbre.php').then(response => {\n        this.setState({\n          tree: response.data\n        });\n        this.changeData(response.data.entree[0].ID_Critere);\n      }).catch(error => console.log(error));\n    }\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"Quiz\",\n      children: [this.state.currentMethod ? /*#__PURE__*/_jsxDEV(Method, {\n        method: this.state.currentMethod,\n        checkedDecision: this.state.checkedDecision,\n        changeData: this.changeData,\n        resumeQuiz: this.resumeQuiz,\n        historic: this.state\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 207,\n        columnNumber: 23\n      }, this) : /*#__PURE__*/_jsxDEV(Issues, {\n        issue: this.state.currentIssue,\n        decisions: this.state.currentDecisions,\n        changeData: this.changeData,\n        step: this.state.step\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 213,\n        columnNumber: 22\n      }, this), /*#__PURE__*/_jsxDEV(Historic, {\n        historic: this.state.historic,\n        backOut: this.backOut\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 219,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 205,\n      columnNumber: 13\n    }, this);\n  }\n\n}\nexport default Quiz;","map":{"version":3,"sources":["C:/wamp64/www/Projet_TER/src/views/Quiz.js"],"names":["React","axios","Issues","Historic","Method","Quiz","Component","constructor","props","changeData","nextIssueId","decision","allChoices","historic","editHistoric","setState","checkedDecision","console","log","state","tree","method","checkMethod","manageMethod","restart","forEach","element","decisions","find","el","ID_Decision","ID_Critere_sortant","step","manageStoreData","alert","issue","criteres","critere","ID_Critere","filter","ID_Critere_entrant","oldIssue","currentIssue","currentDecisions","manageHistoric","historicElement","concat","length","methodes","methode","currentMethod","backOut","ID","type","backIssue","index","indexOf","decisionBeforeMethod","resumeQuiz","componentDidMount","protocol","window","location","host","hostname","url","get","then","response","data","entree","catch","error","render"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport axios from 'axios';\r\n\r\nimport Issues from '../components/quiz/issues';\r\nimport Historic from '../components/quiz/historic';\r\nimport Method from '../components/quiz/method';\r\n\r\n\r\nexport class Quiz extends React.Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            tree : null,\r\n            checkedDecision: null,\r\n            currentMethod: null,\r\n            currentIssue: null,\r\n            currentDecisions: [],\r\n            historic: [],\r\n            step: 0,\r\n        };\r\n        // this.componentDidMount = this.componentDidMount.bind(this);\r\n    }\r\n\r\n\r\n    // met a jour le questionnaire\r\n    // historic : met a jour l'historique normalement\r\n    // editHistoric : met a jour artificiellement quand on est sur une méthode (arret du flux)\r\n    changeData = (nextIssueId, decision = null, allChoices = null, historic = true, editHistoric = false) => {\r\n        // ID de la prochaine question\r\n        this.setState({checkedDecision: decision});\r\n        console.log(this.state.tree);\r\n\r\n        //  Vérifie si la décision renvoie une méthode\r\n        let method = this.checkMethod(decision);\r\n\r\n        if(method){\r\n            this.manageMethod(decision, method);\r\n        } else {\r\n            // si ID prochaine question pas égal a 0 on récupère info\r\n            if(nextIssueId != 0){\r\n                if(allChoices){\r\n                    // si on est sur le critère de fin et qu'on continue, on reinitialise l'historique\r\n                    let restart;\r\n                    allChoices.forEach(element => {\r\n                        let decision = this.state.tree.decisions.find(el => el.ID_Decision === element);\r\n                        if(decision.ID_Critere_sortant === null){\r\n                            restart = true;\r\n                        }\r\n                    });\r\n                    console.log(restart)\r\n                    if(restart){\r\n                        this.setState({\r\n                            historic: [],\r\n                            step: 0,\r\n                        }, () => {\r\n                            this.manageStoreData(nextIssueId, decision, historic, editHistoric);\r\n                        });\r\n                    } else {\r\n                        this.manageStoreData(nextIssueId, decision, historic, editHistoric);\r\n                    }\r\n                } else {\r\n                    this.manageStoreData(nextIssueId, decision, historic, editHistoric);\r\n                }\r\n            }else {\r\n                alert(\"fini\");\r\n            }\r\n        }\r\n    }\r\n\r\n    manageStoreData = (nextIssueId, decision, historic, editHistoric) => {\r\n        // on va chercher la prochaine question et réponses\r\n        let issue = this.state.tree.criteres.find(critere => critere.ID_Critere === nextIssueId);\r\n        let decisions =  this.state.tree.decisions.filter(decision => decision.ID_Critere_entrant === issue.ID_Critere);\r\n        let oldIssue = this.state.currentIssue;\r\n        this.setState({\r\n            currentIssue: issue,\r\n            currentDecisions: decisions,\r\n            step: this.state.step + 1\r\n        }, () => {\r\n            // on met a jour l'historique\r\n            if(historic){\r\n                this.manageHistoric(decision, oldIssue)\r\n            }\r\n            if(editHistoric){\r\n                let historicElement = {\r\n                    issue: this.state.currentIssue,\r\n                    decision: null\r\n                }\r\n                this.setState({historic: this.state.historic.concat(historicElement)});  \r\n            }\r\n        });    \r\n    }\r\n\r\n    // on ajoute la méthode dans l'historique\r\n    manageMethod = (decision, method) => {\r\n        this.state.historic[this.state.historic.length - 1].decision = decision;\r\n        let historicElement = {\r\n            method: method,\r\n        }\r\n        this.setState({historic: this.state.historic.concat(historicElement)}); \r\n    }\r\n\r\n    // on regarde si une méthode est associé a la décision prise\r\n    checkMethod = (decision) => {\r\n        if(decision){\r\n            let method = this.state.tree.methodes.find(methode => methode.ID_Decision === decision.ID_Decision);\r\n            if(method){\r\n                this.setState({currentMethod: method});\r\n                return method;\r\n            }\r\n        }\r\n    }\r\n\r\n    // on retourne dans l'historique \r\n    backOut = (ID, type) => {\r\n        // si on retroune a une question\r\n        if(type == 'issue'){\r\n            // si au moment ou on retourne on est sur une méthode\r\n            if(this.state.currentMethod){\r\n                this.setState({currentMethod: null}, () => {\r\n                    this.backIssue(ID);\r\n                })\r\n            } else {\r\n                this.backIssue(ID);\r\n            }\r\n        } else {\r\n            // si on retourne a une méthode\r\n            let index =  this.state.historic.indexOf(this.state.historic.find(el => el.method));\r\n            let method =  this.state.historic[index].method;\r\n            let decisionBeforeMethod = this.state.historic[index - 1].decision;\r\n            this.state.historic.length = index;\r\n            this.setState({step: index});\r\n            this.changeData(decisionBeforeMethod.ID_Critere_sortant, decisionBeforeMethod, null, false);\r\n        }\r\n    }\r\n\r\n    // on rebind les bonne data en fonction de l'ID du critère sélectionné dans l'historique\r\n    backIssue = (ID) => {\r\n        let index;\r\n        this.changeData(ID, null, null, false);\r\n        this.state.historic.forEach(element => {\r\n            if('issue' in element){\r\n                if(element.issue.ID_Critere === ID){\r\n                    index = this.state.historic.indexOf(element);\r\n                }\r\n            }\r\n        });\r\n        // let index =  this.state.historic.indexOf(this.state.historic.find(el => el.issue.ID_Critere === ID));\r\n        this.state.historic.length = index + 1;\r\n        this.state.historic[index].decision = null;\r\n        this.setState({step: index + 1});\r\n    }\r\n\r\n    // on gère l'historique\r\n    manageHistoric = (decision = null, oldIssue) => {\r\n        // si nous ne somme aps sur une méthode\r\n        // if(!this.state.currentMethod && this.state.historic){\r\n            // on ajoute la décision prise au critère précédent\r\n            this.state.historic.forEach(element => {\r\n                if('issue' in element){\r\n                    if(element.issue.ID_Critere === oldIssue.ID_Critere){\r\n                        element.decision = decision;\r\n                    }\r\n                }\r\n            });\r\n            // console.log(decision)\r\n            // console.log(oldIssue)\r\n            // let condition = this.state.historic.find(el => el.issue.ID_Critere === oldIssue.ID_Critere);\r\n            // if(condition){condition.decision = decision;}\r\n\r\n            // on ajoute le nouveau critère sans décision dans l'historique\r\n            let historicElement = {\r\n                issue: this.state.currentIssue,\r\n                decision: null\r\n            }\r\n            this.setState({historic: this.state.historic.concat(historicElement)});  \r\n        //}  \r\n    }\r\n\r\n    // on reprend le questionnaire la ou on en était depuis une méthode\r\n    resumeQuiz = () => {\r\n        this.setState({currentMethod: null}, () => {\r\n            this.changeData(this.state.checkedDecision.ID_Critere_sortant, null, null, false, true);\r\n        });\r\n    }\r\n\r\n    componentDidMount(){\r\n        let protocol = window.location.protocol;\r\n        let host = window.location.hostname;\r\n        let url = protocol + '//' + host;\r\n\r\n        if(!this.state.tree){\r\n            axios.get(url + '/reactTest/MATUI/API/Controllers/lireArbre.php')\r\n            .then(response => {\r\n                this.setState({tree: response.data});\r\n                this.changeData(response.data.entree[0].ID_Critere);\r\n            })\r\n            .catch(error => console.log(error))\r\n        }\r\n    };\r\n\r\n    render(){\r\n        return (\r\n            <div className=\"Quiz\">\r\n                {this.state.currentMethod\r\n                    ? <Method method={this.state.currentMethod}\r\n                        checkedDecision={this.state.checkedDecision}\r\n                        changeData={this.changeData}  \r\n                        resumeQuiz={this.resumeQuiz} \r\n                        historic={this.state}\r\n                    />\r\n                    :<Issues issue={this.state.currentIssue} \r\n                        decisions={this.state.currentDecisions} \r\n                        changeData={this.changeData}\r\n                        step={this.state.step}\r\n                    />\r\n                }\r\n                <Historic historic={this.state.historic} \r\n                    backOut={this.backOut}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\nexport default Quiz;\r\n"]},"metadata":{},"sourceType":"module"}