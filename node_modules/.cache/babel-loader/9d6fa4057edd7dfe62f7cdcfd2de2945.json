{"ast":null,"code":"var _jsxFileName = \"C:\\\\wamp64\\\\www\\\\Projet_TER\\\\src\\\\views\\\\Quiz.js\";\nimport React from 'react';\nimport axios from 'axios';\nimport Issues from '../components/quiz/issues';\nimport Historic from '../components/quiz/historic';\nimport Method from '../components/quiz/method';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport class Quiz extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.changeData = async (nextIssueId, decision = null, allChoices = null, historic = true, editHistoric = false) => {\n      // ID de la prochaine question\n      this.setState({\n        checkedDecision: decision\n      }); //  Vérifie si la décision renvoie une méthode\n\n      let method = this.checkMethod(decision);\n\n      if (method) {\n        this.manageMethod(decision, method);\n      } else {\n        // si ID prochaine question pas égal a 0 on récupère info\n        if (nextIssueId !== 0) {\n          if (allChoices) {\n            // si on est sur le critère de fin et qu'on continue, on reinitialise l'historique\n            let restart;\n            allChoices.forEach(element => {\n              let decision = this.state.tree.decisions.find(el => el.ID_Decision === element);\n\n              if (decision.ID_Critere_sortant === 0) {\n                // on détecte le critère de fin quand une des décision a un critère sortant null\n                restart = true;\n              }\n            });\n\n            if (restart) {\n              this.addRetainedMethods();\n              this.setState({\n                historic: [],\n                step: 0\n              }, () => {\n                // quand on conitnu a la fin du questionnaire\n                this.manageStoreData(nextIssueId, decision, historic, editHistoric);\n              });\n            } else {\n              // quand on répond au critère (comportement de base)\n              this.manageStoreData(nextIssueId, decision, historic, editHistoric);\n            }\n          } else {\n            // quand on sort d'une méthode (pas de choix fait)\n            this.manageStoreData(nextIssueId, decision, historic, editHistoric);\n          }\n        } else {\n          // quand on sort du questionnaire\n          await this.addRetainedMethods();\n          this.props.history.push({\n            pathname: '/summary',\n            state: {\n              retainedMethods: this.state.retainedMethods\n            }\n          });\n        }\n      }\n    };\n\n    this.manageStoreData = (nextIssueId, decision, historic, editHistoric) => {\n      // on va chercher la prochaine question et réponses\n      let issue = this.state.tree.criteres.find(critere => critere.ID_Critere === nextIssueId);\n      let decisions = this.state.tree.decisions.filter(decision => decision.ID_Critere_entrant === issue.ID_Critere);\n      let oldIssue = this.state.currentIssue;\n      this.setState({\n        currentIssue: issue,\n        currentDecisions: decisions,\n        step: this.state.step + 1\n      }, () => {\n        // on met a jour l'historique\n        if (historic) {\n          this.manageHistoric(decision, oldIssue);\n        }\n\n        if (editHistoric) {\n          let historicElement = {\n            issue: this.state.currentIssue,\n            decision: null\n          };\n          this.setState({\n            historic: this.state.historic.concat(historicElement)\n          });\n        }\n      });\n    };\n\n    this.manageMethod = (decision, method) => {\n      let newHistoric = this.state.historic.slice();\n      newHistoric[newHistoric.length - 1].decision = decision;\n      this.setState({\n        historic: newHistoric\n      });\n      let historicElement = {\n        method: method,\n        checked: false\n      };\n      this.setState({\n        historic: this.state.historic.concat(historicElement)\n      });\n    };\n\n    this.checkedMethod = (method, checked) => {\n      let index;\n      this.state.historic.forEach(element => {\n        if ('method' in element) {\n          if (element.method.ID_Methode === method.ID_Methode) {\n            index = this.state.historic.indexOf(element);\n          }\n        }\n      });\n      let historicElement = {\n        method: method,\n        checked: checked\n      };\n      let newHistoric = this.state.historic.slice();\n      newHistoric[index] = historicElement;\n      this.setState({\n        historic: newHistoric\n      });\n    };\n\n    this.checkMethod = decision => {\n      if (decision) {\n        let method = this.state.tree.methodes.find(methode => methode.ID_Decision === decision.ID_Decision);\n\n        if (method) {\n          this.setState({\n            currentMethod: method\n          });\n          return method;\n        }\n      }\n    };\n\n    this.addRetainedMethods = () => {\n      return new Promise((resolve, reject) => {\n        let methods = [];\n        this.state.historic.forEach(element => {\n          if ('method' in element) {\n            if (element.checked) {\n              if (this.state.retainedMethods.length) {\n                let exist = this.state.retainedMethods.filter(retainedMethod => retainedMethod.method.ID_Methode === element.method.ID_Methode);\n\n                if (!exist.length) {\n                  methods.push(element);\n                }\n              } else {\n                console.log(\"PAR LA\");\n                methods.push(element);\n              }\n            }\n          }\n        });\n        console.log(methods);\n        this.setState({\n          retainedMethods: this.state.retainedMethods.concat(methods)\n        }, () => resolve());\n      });\n    };\n\n    this.backOut = (ID, type) => {\n      // si on retroune a une question\n      if (type === 'issue') {\n        // si au moment ou on retourne on est sur une méthode\n        if (this.state.currentMethod) {\n          this.setState({\n            currentMethod: null\n          }, () => {\n            this.backIssue(ID);\n          });\n        } else {\n          this.backIssue(ID);\n        }\n      } else {\n        // si on retourne a une méthode\n        // let index =  this.state.historic.indexOf(this.state.historic.find(el => el.method));\n        let index;\n        this.state.historic.forEach(element => {\n          if ('method' in element) {\n            if (element.method.ID_Methode === ID) {\n              index = this.state.historic.indexOf(element);\n            }\n          }\n        });\n        let decisionBeforeMethod = this.state.historic[index - 1].decision;\n        this.state.historic.length = index;\n        this.setState({\n          step: index\n        });\n        this.changeData(decisionBeforeMethod.ID_Critere_sortant, decisionBeforeMethod, null, false);\n      }\n    };\n\n    this.backIssue = ID => {\n      let index;\n      this.changeData(ID, null, null, false);\n      this.state.historic.forEach(element => {\n        if ('issue' in element) {\n          if (element.issue.ID_Critere === ID) {\n            index = this.state.historic.indexOf(element);\n          }\n        }\n      }); // let index =  this.state.historic.indexOf(this.state.historic.find(el => el.issue.ID_Critere === ID));\n\n      this.state.historic.length = index + 1;\n      this.state.historic[index].decision = null;\n      this.setState({\n        step: index + 1\n      });\n    };\n\n    this.manageHistoric = (decision = null, oldIssue) => {\n      // si nous ne somme aps sur une méthode\n      this.state.historic.forEach(element => {\n        if ('issue' in element) {\n          if (element.issue.ID_Critere === oldIssue.ID_Critere) {\n            element.decision = decision;\n          }\n        }\n      }); // on ajoute le nouveau critère sans décision dans l'historique\n\n      let historicElement = {\n        issue: this.state.currentIssue,\n        decision: null\n      };\n      this.setState({\n        historic: this.state.historic.concat(historicElement)\n      });\n    };\n\n    this.resumeQuiz = () => {\n      this.setState({\n        currentMethod: null\n      }, () => {\n        this.changeData(this.state.checkedDecision.ID_Critere_sortant, null, null, false, true);\n      });\n    };\n\n    this.state = {\n      tree: null,\n      checkedDecision: null,\n      currentMethod: null,\n      currentIssue: null,\n      retainedMethods: [],\n      currentDecisions: [],\n      historic: [],\n      step: 0\n    }; // this.componentDidMount = this.componentDidMount.bind(this);\n  } // met a jour le questionnaire\n  // historic : met a jour l'historique normalement\n  // editHistoric : met a jour artificiellement quand on est sur une méthode (arret du flux)\n\n\n  componentDidMount() {\n    let protocol = window.location.protocol;\n    let host = window.location.hostname;\n    let url = protocol + '//' + host;\n\n    if (!this.state.tree) {\n      //axios.get(url + '/reactTest/MATUI/API/Controllers/lireArbre.php')\n      axios.get(url + '/Projet_TER/API/Controllers/lireArbre.php').then(response => {\n        this.setState({\n          tree: response.data\n        });\n        this.changeData(response.data.entree[0].ID_Critere);\n      }).catch(error => console.log(error));\n    }\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"Quiz\",\n      children: [this.state.currentMethod ? /*#__PURE__*/_jsxDEV(Method, {\n        method: this.state.currentMethod,\n        checkedDecision: this.state.checkedDecision,\n        changeData: this.changeData,\n        resumeQuiz: this.resumeQuiz,\n        checkedMethod: this.checkedMethod,\n        historic: this.state\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 263,\n        columnNumber: 23\n      }, this) : /*#__PURE__*/_jsxDEV(Issues, {\n        issue: this.state.currentIssue,\n        decisions: this.state.currentDecisions,\n        changeData: this.changeData,\n        step: this.state.step\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 270,\n        columnNumber: 22\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"aside\",\n        children: [/*#__PURE__*/_jsxDEV(Historic, {\n          historic: this.state.historic,\n          backOut: this.backOut\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 278,\n          columnNumber: 21\n        }, this), this.state.retainedMethods.length ? /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"retainedMethods\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"retainedMethods-header\",\n            children: /*#__PURE__*/_jsxDEV(\"h3\", {\n              children: \"Retained methods\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 285,\n              columnNumber: 29\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 284,\n            columnNumber: 26\n          }, this), this.state.retainedMethods.map((element, i) => {\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              children: /*#__PURE__*/_jsxDEV(\"p\", {\n                children: element.method.Libelle\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 289,\n                columnNumber: 37\n              }, this)\n            }, i, false, {\n              fileName: _jsxFileName,\n              lineNumber: 288,\n              columnNumber: 40\n            }, this);\n          })]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 283,\n          columnNumber: 25\n        }, this) : /*#__PURE__*/_jsxDEV(\"div\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 293,\n          columnNumber: 27\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 277,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 261,\n      columnNumber: 13\n    }, this);\n  }\n\n}\nexport default Quiz;","map":{"version":3,"sources":["C:/wamp64/www/Projet_TER/src/views/Quiz.js"],"names":["React","axios","Issues","Historic","Method","Quiz","Component","constructor","props","changeData","nextIssueId","decision","allChoices","historic","editHistoric","setState","checkedDecision","method","checkMethod","manageMethod","restart","forEach","element","state","tree","decisions","find","el","ID_Decision","ID_Critere_sortant","addRetainedMethods","step","manageStoreData","history","push","pathname","retainedMethods","issue","criteres","critere","ID_Critere","filter","ID_Critere_entrant","oldIssue","currentIssue","currentDecisions","manageHistoric","historicElement","concat","newHistoric","slice","length","checked","checkedMethod","index","ID_Methode","indexOf","methodes","methode","currentMethod","Promise","resolve","reject","methods","exist","retainedMethod","console","log","backOut","ID","type","backIssue","decisionBeforeMethod","resumeQuiz","componentDidMount","protocol","window","location","host","hostname","url","get","then","response","data","entree","catch","error","render","map","i","Libelle"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport axios from 'axios';\r\n\r\nimport Issues from '../components/quiz/issues';\r\nimport Historic from '../components/quiz/historic';\r\nimport Method from '../components/quiz/method';\r\n\r\n\r\nexport class Quiz extends React.Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            tree: null,\r\n            checkedDecision: null,\r\n            currentMethod: null,\r\n            currentIssue: null,\r\n            retainedMethods: [],\r\n            currentDecisions: [],\r\n            historic: [],\r\n            step: 0        \r\n        };\r\n        // this.componentDidMount = this.componentDidMount.bind(this);\r\n    }\r\n\r\n    // met a jour le questionnaire\r\n    // historic : met a jour l'historique normalement\r\n    // editHistoric : met a jour artificiellement quand on est sur une méthode (arret du flux)\r\n    changeData = async (nextIssueId, decision = null, allChoices = null, historic = true, editHistoric = false) => {\r\n        // ID de la prochaine question\r\n        this.setState({checkedDecision: decision});\r\n\r\n        //  Vérifie si la décision renvoie une méthode\r\n        let method = this.checkMethod(decision);\r\n\r\n        if(method){\r\n            this.manageMethod(decision, method);\r\n        } else {\r\n            // si ID prochaine question pas égal a 0 on récupère info\r\n            if(nextIssueId !== 0){\r\n                if(allChoices){\r\n                    // si on est sur le critère de fin et qu'on continue, on reinitialise l'historique\r\n                    let restart;\r\n                    allChoices.forEach(element => {\r\n                        let decision = this.state.tree.decisions.find(el => el.ID_Decision === element);\r\n                        if(decision.ID_Critere_sortant === 0){\r\n                            // on détecte le critère de fin quand une des décision a un critère sortant null\r\n                            restart = true;\r\n                        }\r\n                    });\r\n                    if(restart){\r\n                        this.addRetainedMethods();\r\n                        this.setState({\r\n                            historic: [],\r\n                            step: 0,\r\n                        }, () => {\r\n                            // quand on conitnu a la fin du questionnaire\r\n                            this.manageStoreData(nextIssueId, decision, historic, editHistoric);\r\n                        });\r\n                    } else {\r\n                        // quand on répond au critère (comportement de base)\r\n                        this.manageStoreData(nextIssueId, decision, historic, editHistoric);\r\n                    }\r\n                } else {\r\n                    // quand on sort d'une méthode (pas de choix fait)\r\n                    this.manageStoreData(nextIssueId, decision, historic, editHistoric);\r\n                }\r\n            }else {\r\n                // quand on sort du questionnaire\r\n                await this.addRetainedMethods();         \r\n                this.props.history.push({\r\n                    pathname: '/summary',\r\n                    state: { retainedMethods: this.state.retainedMethods }\r\n                })            \r\n            }\r\n        }\r\n    }\r\n\r\n    manageStoreData = (nextIssueId, decision, historic, editHistoric) => {\r\n        // on va chercher la prochaine question et réponses\r\n        let issue = this.state.tree.criteres.find(critere => critere.ID_Critere === nextIssueId);\r\n        let decisions =  this.state.tree.decisions.filter(decision => decision.ID_Critere_entrant === issue.ID_Critere);\r\n        let oldIssue = this.state.currentIssue;\r\n        this.setState({\r\n            currentIssue: issue,\r\n            currentDecisions: decisions,\r\n            step: this.state.step + 1\r\n        }, () => {\r\n            // on met a jour l'historique\r\n            if(historic){\r\n                this.manageHistoric(decision, oldIssue)\r\n            }\r\n            if(editHistoric){\r\n                let historicElement = {\r\n                    issue: this.state.currentIssue,\r\n                    decision: null\r\n                }\r\n                this.setState({historic: this.state.historic.concat(historicElement)});  \r\n            }\r\n        });    \r\n    }\r\n\r\n    // on ajoute la méthode dans l'historique\r\n    manageMethod = (decision, method) => {\r\n        let newHistoric = this.state.historic.slice();\r\n        newHistoric[newHistoric.length - 1].decision = decision;\r\n        this.setState({historic: newHistoric}); \r\n\r\n        let historicElement = {\r\n            method: method,\r\n            checked: false\r\n        }\r\n        this.setState({historic: this.state.historic.concat(historicElement)}); \r\n    }\r\n\r\n    checkedMethod = (method, checked) => {\r\n        let index;\r\n        this.state.historic.forEach(element => {\r\n            if('method' in element){\r\n                if(element.method.ID_Methode === method.ID_Methode){\r\n                    index = this.state.historic.indexOf(element);\r\n                }\r\n            }\r\n        });\r\n        let historicElement = {\r\n            method: method,\r\n            checked: checked\r\n        }\r\n        let newHistoric = this.state.historic.slice();\r\n        newHistoric[index] = historicElement;\r\n        this.setState({historic: newHistoric}); \r\n    }\r\n\r\n    // on regarde si une méthode est associé a la décision prise\r\n    checkMethod = (decision) => {\r\n        if(decision){\r\n            let method = this.state.tree.methodes.find(methode => methode.ID_Decision === decision.ID_Decision);\r\n            if(method){\r\n                this.setState({currentMethod: method});\r\n                return method;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ajoute les méthodes retenu lors du précédent passage\r\n    // se produit lorsque on restart le questionnaire\r\n    addRetainedMethods = () => {\r\n        return new Promise((resolve,reject)=>{\r\n            let methods = [];\r\n            this.state.historic.forEach(element => {\r\n                if('method' in element){\r\n                    if(element.checked){\r\n                        if(this.state.retainedMethods.length){\r\n                            let exist =  this.state.retainedMethods.filter(retainedMethod => retainedMethod.method.ID_Methode === element.method.ID_Methode);\r\n                            if(!exist.length){\r\n                                methods.push(element);\r\n                            }\r\n                        } else {\r\n                            console.log(\"PAR LA\")\r\n                            methods.push(element);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            console.log(methods)\r\n        this.setState({retainedMethods: this.state.retainedMethods.concat(methods)}, () => resolve()); \r\n        });\r\n    }\r\n\r\n    // on retourne dans l'historique \r\n    backOut = (ID, type) => {\r\n        // si on retroune a une question\r\n        if(type === 'issue'){\r\n            // si au moment ou on retourne on est sur une méthode\r\n            if(this.state.currentMethod){\r\n                this.setState({currentMethod: null}, () => {\r\n                    this.backIssue(ID);\r\n                })\r\n            } else {\r\n                this.backIssue(ID);\r\n            }\r\n        } else {\r\n            // si on retourne a une méthode\r\n            // let index =  this.state.historic.indexOf(this.state.historic.find(el => el.method));\r\n            let index;\r\n            this.state.historic.forEach(element => {\r\n                if('method' in element){\r\n                    if(element.method.ID_Methode === ID){\r\n                        index = this.state.historic.indexOf(element);\r\n                    }\r\n                }\r\n            });\r\n            let decisionBeforeMethod = this.state.historic[index - 1].decision;   \r\n            this.state.historic.length = index;\r\n            this.setState({step: index});\r\n            this.changeData(decisionBeforeMethod.ID_Critere_sortant, decisionBeforeMethod, null, false);\r\n        }\r\n    }\r\n\r\n    // on rebind les bonne data en fonction de l'ID du critère sélectionné dans l'historique\r\n    backIssue = (ID) => {\r\n        let index;\r\n        this.changeData(ID, null, null, false);\r\n        this.state.historic.forEach(element => {\r\n            if('issue' in element){\r\n                if(element.issue.ID_Critere === ID){\r\n                    index = this.state.historic.indexOf(element);\r\n                }\r\n            }\r\n        });\r\n        // let index =  this.state.historic.indexOf(this.state.historic.find(el => el.issue.ID_Critere === ID));\r\n        this.state.historic.length = index + 1;\r\n        this.state.historic[index].decision = null;\r\n        this.setState({step: index + 1});\r\n    }\r\n\r\n    // on gère l'historique\r\n    manageHistoric = (decision = null, oldIssue) => {\r\n        // si nous ne somme aps sur une méthode\r\n        this.state.historic.forEach(element => {\r\n            if('issue' in element){\r\n                if(element.issue.ID_Critere === oldIssue.ID_Critere){\r\n                    element.decision = decision;\r\n                }\r\n            }\r\n        });\r\n\r\n        // on ajoute le nouveau critère sans décision dans l'historique\r\n        let historicElement = {\r\n            issue: this.state.currentIssue,\r\n            decision: null\r\n        }\r\n        this.setState({historic: this.state.historic.concat(historicElement)}); \r\n    }\r\n\r\n    // on reprend le questionnaire la ou on en était depuis une méthode\r\n    resumeQuiz = () => {\r\n        this.setState({currentMethod: null}, () => {\r\n            this.changeData(this.state.checkedDecision.ID_Critere_sortant, null, null, false, true);\r\n        });\r\n    }\r\n\r\n    componentDidMount(){\r\n        let protocol = window.location.protocol;\r\n        let host = window.location.hostname;\r\n        let url = protocol + '//' + host;\r\n\r\n        if(!this.state.tree){\r\n            //axios.get(url + '/reactTest/MATUI/API/Controllers/lireArbre.php')\r\n            axios.get(url + '/Projet_TER/API/Controllers/lireArbre.php')\r\n            .then(response => {\r\n                this.setState({tree: response.data});\r\n                this.changeData(response.data.entree[0].ID_Critere);\r\n            })\r\n            .catch(error => console.log(error))\r\n        }\r\n    };\r\n\r\n    render(){\r\n        return (\r\n            <div className=\"Quiz\">\r\n                {this.state.currentMethod\r\n                    ? <Method method={this.state.currentMethod}\r\n                        checkedDecision={this.state.checkedDecision}\r\n                        changeData={this.changeData}  \r\n                        resumeQuiz={this.resumeQuiz} \r\n                        checkedMethod={this.checkedMethod}\r\n                        historic={this.state}\r\n                    />\r\n                    :<Issues issue={this.state.currentIssue} \r\n                        decisions={this.state.currentDecisions} \r\n                        changeData={this.changeData}\r\n                        step={this.state.step}\r\n                    />\r\n                }\r\n                \r\n                <div className=\"aside\">\r\n                    <Historic historic={this.state.historic} \r\n                        backOut={this.backOut}\r\n                    />\r\n\r\n                    {this.state.retainedMethods.length ?\r\n                        <div className=\"retainedMethods\">  \r\n                         <div className=\"retainedMethods-header\">\r\n                            <h3>Retained methods</h3>\r\n                        </div>              \r\n                            {this.state.retainedMethods.map((element, i) => {   \r\n                                return(<div key={i}>\r\n                                    <p>{element.method.Libelle}</p>\r\n                                </div>)\r\n                            })}\r\n                        </div>\r\n                        : <div></div>\r\n                    }\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\nexport default Quiz;\r\n"]},"metadata":{},"sourceType":"module"}