{"ast":null,"code":"var _jsxFileName = \"C:\\\\wamp64\\\\www\\\\Projet_TER\\\\src\\\\views\\\\Tree.js\",\n    _s = $RefreshSig$();\n\nimport React, { useRef, useState, useEffect } from 'react';\nimport $, { get } from 'jquery';\nimport axios from 'axios';\nimport ReactFlow, { addEdge, ReactFlowProvider, removeElements } from 'react-flow-renderer';\nimport Loader from '../components/Loader';\nimport Toolbar from '../components/Toolbar';\nimport CustomNode from '../components/tree/CustomNode';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction Tree() {\n  _s();\n\n  const nodeTypes = {\n    critereNode: CustomNode\n  };\n  const colors = ['black', 'marron', 'blue', 'red', 'purple', 'fushia', 'green', 'lime', 'yellow', 'navy', 'aqua', 'aquamarine', 'chocolate', 'coral', 'crimson', 'darkcyan', 'darkgreen', 'darkorange', 'darkseagreen', 'deeppink', 'gold', 'indgo', 'lightcoral'];\n  const [initialTree, setInitialTree] = useState(null);\n  const [nextId, setNextId] = useState(\"0\");\n  const [nextEdgeId, setNextEdgeId] = useState(\"D1\");\n  const [nextMethodId, setNextMethodId] = useState(\"M1\");\n  const [editedElement, setEditedElement] = useState(null);\n  const [elements, setElements] = useState([]);\n  const reactFlowWrapper = useRef(null);\n  const [reactFlowInstance, setReactFlowInstance] = useState(null);\n\n  const onElementsRemove = elementsToRemove => setElements(els => removeElements(elementsToRemove, els));\n\n  const onConnect = params => setElements(els => addEdge({ ...params,\n    id: getEdgeId(),\n    arrowHeadType: 'arrowclosed',\n    label: 'edge label',\n    type: 'smoothstep'\n  }, els, setNextEdgeId(\"D\" + (parseInt(nextEdgeId.slice(1)) + 1).toString()))); // const onLoad = (_reactFlowInstance) => setReactFlowInstance(_reactFlowInstance);\n  // const [reactFlowInstance, setReactFlowInstance] = useState(null);\n  // HOOKS REACT-FLOW\n\n\n  const onDragOver = event => {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'move';\n  };\n\n  const onDrop = event => {\n    event.preventDefault(); //check if input/output already exists\n\n    const type = event.dataTransfer.getData('application/reactflow');\n\n    if (type != null && type == \"input\" || type == \"output\") {\n      if (checkExist(type)) {\n        return alert(\"Désolé, il ne peut y avoir qu'un seul noeud de type \" + type);\n      }\n    }\n\n    const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();\n    const position = reactFlowInstance.project({\n      x: event.clientX - reactFlowBounds.left,\n      y: event.clientY - reactFlowBounds.top\n    });\n    createNode(getId(), type, position); // if(type === 'default' || type === 'critereNode'){\n    //     setNextId((parseInt(nextId) + 1).toString());\n    // }\n  };\n\n  const onElementClick = (event, element) => {\n    // event.preventDefault();\n    // let el = $(\"div\").find(`[data-id='${element.id}']`)\n    if (element.type === \"input\" || element.type === \"output\") {\n      console.log(\"Impossible de modifier le noeud (début ou fin)\");\n    } else {\n      openEdition(element);\n    }\n  };\n\n  const onPaneClick = event => {\n    event.preventDefault();\n    closeEdition();\n  }; // FUNCTIONS\n\n\n  function getId() {\n    return nextId;\n  }\n\n  function getEdgeId() {\n    return nextEdgeId;\n  }\n\n  function getMethodId() {\n    return nextMethodId;\n  } // add input in selected node\n\n\n  function openEdition(element) {\n    if (!editedElement) {\n      let el = $(\"div\").find(`[data-id='${element.id}']`);\n      console.log(el);\n      let text = el.text();\n      el.css(\"font-size\", 0);\n      el.append(`<input type=\"text\" id=\"label\" name=\"label\" value=\"${text}\"/>`);\n      setEditedElement(el);\n    }\n  } // remove input in selected node and save label\n\n\n  function closeEdition() {\n    if (editedElement) {\n      let newValue = editedElement.children(\"input\").val();\n      elements.forEach(element => {\n        if (element.id == editedElement.data(\"id\")) {\n          element.data.label = newValue;\n        }\n      });\n      editedElement.children(\"input\").remove();\n      editedElement.css(\"font-size\", \"12px\");\n      setEditedElement(null);\n    }\n  }\n\n  function createNode(id, type, position, label) {\n    let newNode;\n\n    switch (type) {\n      case 'input':\n        newNode = {\n          id: \"0\",\n          type,\n          position,\n          data: {\n            label: label\n          }\n        };\n        break;\n\n      case 'output':\n        newNode = {\n          id: \"S0\",\n          type,\n          position,\n          data: {\n            label: label\n          }\n        };\n        break;\n\n      case 'critereNode':\n        if (label) {\n          newNode = {\n            id: id,\n            type,\n            position,\n            data: {\n              label: label\n            }\n          };\n\n          if (id > getId()) {\n            setNextId((parseInt(id) + 1).toString());\n          }\n        } else {\n          newNode = {\n            id: getId(),\n            type,\n            position,\n            data: {\n              label: `${type} node`\n            }\n          };\n          setNextId((parseInt(nextId) + 1).toString());\n        }\n\n        break;\n\n      case 'default':\n        if (label) {\n          newNode = {\n            id: id,\n            type,\n            position,\n            data: {\n              label: label\n            }\n          };\n\n          if (parseInt(id.slice(1)) > getMethodId().slice(1)) {\n            setNextMethodId(\"M\" + (parseInt(id.slice(1)) + 1).toString());\n          }\n        } else {\n          newNode = {\n            id: getMethodId(),\n            type,\n            position,\n            data: {\n              label: `${type} node`\n            }\n          };\n          setNextMethodId(\"M\" + (parseInt(getMethodId().slice(1)) + 1).toString());\n        }\n\n        break;\n    }\n\n    setElements(es => es.concat(newNode));\n  }\n\n  function createEdge(id, id_source, id_target, label, color) {\n    let newEdge = {\n      id: id,\n      source: id_source,\n      target: id_target,\n      type: 'smoothstep',\n      arrowHeadType: 'arrowclosed',\n      label: label,\n      style: {\n        stroke: color\n      }\n    };\n    setElements(es => es.concat(newEdge));\n\n    if (id.substring(0, 2) != \"DM\") {\n      if (parseInt(id.slice(1)) > getEdgeId().slice(1)) {\n        setNextEdgeId(\"D\" + (parseInt(id.slice(1)) + 1).toString());\n      }\n    }\n  } // check if a node type already exists\n\n\n  function checkExist(type) {\n    if (elements) {\n      for (let i = 0; i < elements.length; i++) {\n        if (elements[i].type == type) {\n          return true;\n        }\n      }\n\n      return false;\n    } else {\n      return true;\n    }\n  } // INIT TREE\n\n\n  function initTree() {\n    createNode('0', 'input', {\n      x: 0,\n      y: 0\n    });\n    let firstNode = initialTree.criteres.find(el => el.ID_Critere === initialTree.entree[0].ID_Critere);\n    createNode(firstNode.ID_Critere, 'critereNode', {\n      x: 0,\n      y: 100\n    }, firstNode.Libelle);\n    createEdge('D0', '0', firstNode.ID_Critere, null);\n    initNodes(initialTree.entree[0].ID_Critere);\n  }\n\n  function initNodes(start) {\n    initialTree.criteres.forEach(node => {\n      let color = colors[0];\n      colors.splice(0, 1);\n\n      if (node.ID_Critere !== start) {\n        createNode(node.ID_Critere, 'critereNode', {\n          x: node.x,\n          y: node.y\n        }, node.Libelle);\n      } // on récupère les décisions attaché au critère et on regarde si un méthode est attaché\n\n\n      let decisions = getDecisions(node.ID_Critere);\n      decisions.forEach(decision => {\n        let method = getMethod(decision);\n\n        if (method) {\n          createNode(\"M\" + method.ID_Methode, 'default', {\n            x: method.x,\n            y: method.y\n          }, method.Libelle);\n          createEdge(\"D\" + decision.ID_Decision, node.ID_Critere, \"M\" + method.ID_Methode, decision.Libelle, color);\n          createEdge(\"DM\" + decision.ID_Decision, \"M\" + method.ID_Methode, decision.ID_Critere_sortant, null, color);\n        } else {\n          if (decision.ID_Critere_sortant) {\n            createEdge(\"D\" + decision.ID_Decision, decision.ID_Critere_entrant, decision.ID_Critere_sortant, decision.Libelle, color);\n          }\n        }\n      });\n    });\n  }\n\n  function getDecisions(nodeId) {\n    let decisions = initialTree.decisions.filter(decision => decision.ID_Critere_entrant === nodeId);\n    return decisions;\n  }\n\n  function getMethod(decision) {\n    let method = initialTree.methodes.find(method => method.ID_Decision === decision.ID_Decision);\n    return method;\n  }\n\n  useEffect(() => {\n    if (!initialTree) {\n      let protocol = window.location.protocol;\n      let host = window.location.hostname;\n      let url = protocol + '//' + host;\n      axios.get(url + '/reactTest/MATUI/API/Controllers/lireArbre.php').then(response => {\n        setInitialTree(response.data);\n      }).catch(error => console.log(error));\n    }\n  }, []);\n  useEffect(() => {\n    if (initialTree) {\n      initTree();\n    }\n  }, [initialTree]);\n  useEffect(() => {\n    if (nextMethodId) {\n      console.log(nextMethodId);\n    }\n  }, [nextMethodId]); // RECONSTRUCTION DE L'ARBRE\n\n  /*\r\n  types :\r\n      - input (start node)\r\n      - output (end node)\r\n      - default (node)\r\n      - smoothstep (edge)\r\n  */\n\n  function printNodes() {\n    let flow = reactFlowInstance.toObject();\n    let finalTree = {\n      entree: [],\n      sortie: [],\n      criteres: [],\n      methodes: [],\n      decisions: []\n    };\n    flow.elements.forEach(element => {\n      let transformedElement;\n\n      switch (element.type) {\n        case 'critereNode':\n          transformedElement = transformToCritere(element);\n          finalTree.criteres.push(transformedElement);\n          break;\n\n        case 'default':\n          transformedElement = transformToMethod(element, flow);\n          finalTree.methodes.push(transformedElement);\n          break;\n\n        case 'smoothstep':\n          if (element.label) {\n            transformedElement = transformToDecision(element, flow);\n            finalTree.decisions.push(transformedElement);\n          }\n\n          break;\n\n        case 'input':\n          transformedElement = transformToEntree(element, flow);\n          finalTree.entree.push(transformedElement);\n          break;\n\n        case 'output':\n          // transformedElement = transformToSortie(element);\n          finalTree.sortie.push(element);\n          break;\n      }\n    });\n    console.log(initialTree);\n    console.log(finalTree);\n  }\n\n  function transformToCritere(element) {\n    let critere = {\n      ID_Critere: element.id,\n      Libelle: element.data.label,\n      x: element.position.x,\n      y: element.position.y\n    };\n    return critere;\n  }\n\n  function transformToMethod(element, flow) {\n    let decision = flow.elements.find(el => el.type === \"smoothstep\" && el.target === element.id);\n    let method = {\n      ID_Method: element.id.slice(1),\n      ID_Decision: decision.id.slice(1),\n      Libelle: element.data.label,\n      x: element.position.x,\n      y: element.position.y\n    };\n    return method;\n  }\n\n  function transformToDecision(element, flow) {\n    let outDecision;\n\n    if (element.target.includes(\"M\")) {\n      outDecision = flow.elements.find(el => el.type === \"smoothstep\" && el.source === element.target);\n    }\n\n    let decision = {\n      ID_Decision: element.id.slice(1),\n      ID_Critere_entrant: element.source,\n      ID_Critere_sortant: outDecision ? outDecision.target : element.target,\n      Libelle: element.label\n    };\n    return decision;\n  }\n\n  function transformToEntree(element, flow) {\n    let outDecision = flow.elements.find(el => el.type === \"smoothstep\" && el.source === element.id);\n    let critere = {\n      ID_Entree: element.id,\n      ID_Critere: outDecision.target,\n      x: element.position.x,\n      y: element.position.y\n    };\n    return critere;\n  }\n\n  function transformToSortie(element) {\n    let critere = {\n      ID_Critere: element.id,\n      x: element.position.x,\n      y: element.position.y\n    };\n    return critere;\n  }\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"Tree\",\n    children: elements ? /*#__PURE__*/_jsxDEV(ReactFlowProvider, {\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"reactflow-wrapper\",\n        ref: reactFlowWrapper,\n        children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n          children: \"Tree\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 405,\n          columnNumber: 25\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            height: 600,\n            backgroundColor: 'lightgrey',\n            margin: '100px'\n          },\n          children: /*#__PURE__*/_jsxDEV(ReactFlow, {\n            elements: elements,\n            nodeTypes: nodeTypes,\n            onElementsRemove: onElementsRemove,\n            onConnect: onConnect,\n            deleteKeyCode: 46,\n            onLoad: setReactFlowInstance,\n            onDrop: onDrop,\n            onDragOver: onDragOver,\n            onElementClick: onElementClick,\n            onPaneClick: onPaneClick\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 407,\n            columnNumber: 29\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 406,\n          columnNumber: 25\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => printNodes(),\n          children: \"print nodes\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 419,\n          columnNumber: 25\n        }, this), /*#__PURE__*/_jsxDEV(Toolbar, {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 420,\n          columnNumber: 25\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 404,\n        columnNumber: 21\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 403,\n      columnNumber: 17\n    }, this) : /*#__PURE__*/_jsxDEV(Loader, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 423,\n      columnNumber: 15\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 401,\n    columnNumber: 9\n  }, this);\n}\n\n_s(Tree, \"BLQnitrT6aXwak/Kh7mG0sgTxcE=\");\n\n_c = Tree;\nexport default Tree;\n\nvar _c;\n\n$RefreshReg$(_c, \"Tree\");","map":{"version":3,"sources":["C:/wamp64/www/Projet_TER/src/views/Tree.js"],"names":["React","useRef","useState","useEffect","$","get","axios","ReactFlow","addEdge","ReactFlowProvider","removeElements","Loader","Toolbar","CustomNode","Tree","nodeTypes","critereNode","colors","initialTree","setInitialTree","nextId","setNextId","nextEdgeId","setNextEdgeId","nextMethodId","setNextMethodId","editedElement","setEditedElement","elements","setElements","reactFlowWrapper","reactFlowInstance","setReactFlowInstance","onElementsRemove","elementsToRemove","els","onConnect","params","id","getEdgeId","arrowHeadType","label","type","parseInt","slice","toString","onDragOver","event","preventDefault","dataTransfer","dropEffect","onDrop","getData","checkExist","alert","reactFlowBounds","current","getBoundingClientRect","position","project","x","clientX","left","y","clientY","top","createNode","getId","onElementClick","element","console","log","openEdition","onPaneClick","closeEdition","getMethodId","el","find","text","css","append","newValue","children","val","forEach","data","remove","newNode","es","concat","createEdge","id_source","id_target","color","newEdge","source","target","style","stroke","substring","i","length","initTree","firstNode","criteres","ID_Critere","entree","Libelle","initNodes","start","node","splice","decisions","getDecisions","decision","method","getMethod","ID_Methode","ID_Decision","ID_Critere_sortant","ID_Critere_entrant","nodeId","filter","methodes","protocol","window","location","host","hostname","url","then","response","catch","error","printNodes","flow","toObject","finalTree","sortie","transformedElement","transformToCritere","push","transformToMethod","transformToDecision","transformToEntree","critere","ID_Method","outDecision","includes","ID_Entree","transformToSortie","height","backgroundColor","margin"],"mappings":"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","sourcesContent":["import React, {useRef, useState, useEffect} from 'react';\r\nimport $, { get } from 'jquery';\r\nimport axios from 'axios';\r\nimport ReactFlow, {addEdge, ReactFlowProvider, removeElements} from 'react-flow-renderer';\r\n\r\nimport Loader from '../components/Loader';\r\nimport Toolbar from '../components/Toolbar';\r\nimport CustomNode from '../components/tree/CustomNode';\r\n\r\nfunction Tree() {\r\n    const nodeTypes = {\r\n        critereNode: CustomNode,\r\n    };\r\n\r\n    const colors = ['black', 'marron', 'blue', 'red', 'purple', 'fushia', 'green', 'lime', 'yellow',\r\n'navy', 'aqua', 'aquamarine', 'chocolate', 'coral', 'crimson', 'darkcyan', 'darkgreen', 'darkorange', 'darkseagreen',\r\n'deeppink', 'gold', 'indgo', 'lightcoral'];\r\n\r\n    const [initialTree, setInitialTree] = useState(null);\r\n    const [nextId, setNextId] = useState(\"0\");\r\n    const [nextEdgeId, setNextEdgeId] = useState(\"D1\");\r\n    const [nextMethodId, setNextMethodId] = useState(\"M1\");\r\n\r\n    const [editedElement, setEditedElement] = useState(null);\r\n    const [elements, setElements] = useState([]);\r\n\r\n    const reactFlowWrapper = useRef(null);\r\n    const [reactFlowInstance, setReactFlowInstance] = useState(null);\r\n    const onElementsRemove = (elementsToRemove) => setElements((els) => removeElements(elementsToRemove, els));\r\n    const onConnect = (params) => setElements((els) => addEdge({\r\n        ...params,\r\n        id: getEdgeId(), arrowHeadType: 'arrowclosed', label: 'edge label', type: 'smoothstep',\r\n    }, els, setNextEdgeId(\"D\" + (parseInt(nextEdgeId.slice(1)) + 1).toString())));\r\n    // const onLoad = (_reactFlowInstance) => setReactFlowInstance(_reactFlowInstance);\r\n    // const [reactFlowInstance, setReactFlowInstance] = useState(null);\r\n\r\n\r\n\r\n    // HOOKS REACT-FLOW\r\n\r\n    const onDragOver = (event) => {\r\n        event.preventDefault();\r\n        event.dataTransfer.dropEffect = 'move';\r\n    };\r\n\r\n    const onDrop = (event) => {\r\n        event.preventDefault();\r\n\r\n        //check if input/output already exists\r\n        const type = event.dataTransfer.getData('application/reactflow');\r\n        if (type!= null && type == \"input\" || type == \"output\") {\r\n            if (checkExist(type)) {\r\n                return alert(\"Désolé, il ne peut y avoir qu'un seul noeud de type \" + type)\r\n            }\r\n        }\r\n\r\n        const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();\r\n        const position = reactFlowInstance.project({\r\n            x: event.clientX - reactFlowBounds.left,\r\n            y: event.clientY - reactFlowBounds.top,\r\n        });\r\n        createNode(getId(), type, position);\r\n        // if(type === 'default' || type === 'critereNode'){\r\n        //     setNextId((parseInt(nextId) + 1).toString());\r\n        // }\r\n    };\r\n\r\n    const onElementClick = (event, element) => {\r\n        // event.preventDefault();\r\n        // let el = $(\"div\").find(`[data-id='${element.id}']`)\r\n        if (element.type === \"input\" || element.type === \"output\") {\r\n            console.log(\"Impossible de modifier le noeud (début ou fin)\")\r\n        } else {\r\n            openEdition(element);\r\n        }\r\n    }\r\n\r\n    const onPaneClick = (event) => {\r\n        event.preventDefault();\r\n        closeEdition();\r\n    }\r\n\r\n\r\n    // FUNCTIONS\r\n\r\n    function getId() {\r\n        return nextId;\r\n    }\r\n\r\n    function getEdgeId() {\r\n        return nextEdgeId;\r\n    }\r\n\r\n    function getMethodId() {\r\n        return nextMethodId;\r\n    }\r\n\r\n    // add input in selected node\r\n    function openEdition(element) {\r\n        if (!editedElement) {\r\n            let el = $(\"div\").find(`[data-id='${element.id}']`);\r\n            console.log(el);\r\n            let text = el.text();\r\n            el.css(\"font-size\", 0);\r\n            el.append(`<input type=\"text\" id=\"label\" name=\"label\" value=\"${text}\"/>`);\r\n            setEditedElement(el)\r\n        }\r\n    }\r\n\r\n    // remove input in selected node and save label\r\n    function closeEdition() {\r\n        if (editedElement) {\r\n            let newValue = editedElement.children(\"input\").val();\r\n            elements.forEach(element => {\r\n                if (element.id == editedElement.data(\"id\")) {\r\n                    element.data.label = newValue;\r\n                }\r\n            });\r\n            editedElement.children(\"input\").remove();\r\n            editedElement.css(\"font-size\", \"12px\");\r\n            setEditedElement(null)\r\n        }\r\n    }\r\n\r\n    function createNode(id, type, position, label) {\r\n        let newNode;\r\n        switch (type) {\r\n            case 'input':\r\n                newNode = {\r\n                    id: \"0\",\r\n                    type,\r\n                    position,\r\n                    data: {label: label},\r\n                };\r\n                break;\r\n            case 'output':\r\n                newNode = {\r\n                    id: \"S0\",\r\n                    type,\r\n                    position,\r\n                    data: {label: label},\r\n                };\r\n                break;\r\n            case 'critereNode':\r\n                if(label){\r\n                    newNode = {\r\n                        id: id,\r\n                        type,\r\n                        position,\r\n                        data: {label: label},\r\n                    };\r\n                    if(id > getId()){\r\n                        setNextId((parseInt(id) + 1).toString());\r\n                    }      \r\n                } else {\r\n                    newNode = {\r\n                        id: getId(),\r\n                        type,\r\n                        position,\r\n                        data: {label: `${type} node`},\r\n                    };\r\n                    setNextId((parseInt(nextId) + 1).toString());\r\n                }\r\n                break;\r\n            case 'default':\r\n                if(label){\r\n                    newNode = {\r\n                        id: id,\r\n                        type,\r\n                        position,\r\n                        data: {label: label},\r\n                    };\r\n                    if(parseInt(id.slice(1)) > getMethodId().slice(1)){\r\n                        setNextMethodId(\"M\" + (parseInt(id.slice(1)) + 1).toString());\r\n                    }               \r\n                } else {\r\n                    newNode = {\r\n                        id: getMethodId(),\r\n                        type,\r\n                        position,\r\n                        data: {label: `${type} node`},\r\n                    };\r\n                    setNextMethodId(\"M\" + (parseInt(getMethodId().slice(1)) + 1).toString());\r\n                }\r\n                break;\r\n        }\r\n        setElements((es) => es.concat(newNode));\r\n    }\r\n    \r\n\r\n    function createEdge(id, id_source, id_target, label, color){\r\n        let newEdge = {\r\n            id: id,\r\n            source: id_source,\r\n            target: id_target,\r\n            type: 'smoothstep',\r\n            arrowHeadType: 'arrowclosed',\r\n            label: label,\r\n            style: { stroke: color },\r\n        }\r\n        setElements((es) => es.concat(newEdge));\r\n        if(id.substring(0, 2) != \"DM\"){\r\n            if(parseInt(id.slice(1)) > getEdgeId().slice(1)){\r\n                setNextEdgeId(\"D\" + (parseInt(id.slice(1)) + 1).toString());\r\n            }\r\n        }    \r\n    }\r\n\r\n    // check if a node type already exists\r\n    function checkExist(type) {\r\n        if(elements){\r\n            for (let i = 0; i < elements.length; i++) {\r\n                if (elements[i].type == type) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // INIT TREE\r\n\r\n    function initTree(){\r\n        createNode('0', 'input', {x: 0, y: 0});\r\n        let firstNode = initialTree.criteres.find(el => el.ID_Critere === initialTree.entree[0].ID_Critere);\r\n        createNode(firstNode.ID_Critere,'critereNode', {x: 0, y: 100}, firstNode.Libelle);\r\n        createEdge('D0' ,'0', firstNode.ID_Critere, null);\r\n        initNodes(initialTree.entree[0].ID_Critere);\r\n    }\r\n\r\n    function initNodes(start){\r\n        initialTree.criteres.forEach(node => {\r\n            let color = colors[0]\r\n            colors.splice(0, 1);\r\n            if(node.ID_Critere !== start){\r\n                createNode(node.ID_Critere, 'critereNode',  {x: node.x, y: node.y}, node.Libelle)\r\n            }\r\n            // on récupère les décisions attaché au critère et on regarde si un méthode est attaché\r\n            let decisions = getDecisions(node.ID_Critere);\r\n            decisions.forEach(decision => {\r\n                let method = getMethod(decision);\r\n                if(method){\r\n                    createNode(\"M\" + method.ID_Methode, 'default',  {x: method.x, y: method.y}, method.Libelle);\r\n                    createEdge(\"D\" + decision.ID_Decision ,node.ID_Critere, \"M\" + method.ID_Methode, decision.Libelle, color);\r\n                    createEdge(\"DM\" + decision.ID_Decision, \"M\" + method.ID_Methode, decision.ID_Critere_sortant, null, color);\r\n                } else {\r\n                    if(decision.ID_Critere_sortant){\r\n                        createEdge(\"D\" + decision.ID_Decision, decision.ID_Critere_entrant, decision.ID_Critere_sortant, decision.Libelle, color);\r\n                    }\r\n                }\r\n            })                \r\n        });\r\n    }\r\n\r\n    function getDecisions(nodeId){\r\n        let decisions =  initialTree.decisions.filter(decision => decision.ID_Critere_entrant === nodeId);\r\n        return decisions;\r\n    }\r\n\r\n    function getMethod(decision){\r\n        let method =  initialTree.methodes.find(method => method.ID_Decision === decision.ID_Decision);\r\n        return method;\r\n    }\r\n\r\n    useEffect(() => {\r\n        if(!initialTree){\r\n            let protocol = window.location.protocol;\r\n            let host = window.location.hostname;\r\n            let url = protocol + '//' + host;\r\n                axios.get(url + '/reactTest/MATUI/API/Controllers/lireArbre.php')\r\n                .then(response => {\r\n                    setInitialTree(response.data)\r\n                })\r\n                .catch(error => console.log(error))\r\n        }\r\n    },[]);\r\n\r\n    useEffect(() => {\r\n        if(initialTree){\r\n            initTree();\r\n        }\r\n    }, [initialTree]);\r\n\r\n    \r\n    useEffect(() => {\r\n        if(nextMethodId){\r\n            console.log(nextMethodId)\r\n        }\r\n    }, [nextMethodId]);\r\n\r\n     // RECONSTRUCTION DE L'ARBRE\r\n\r\n    /*\r\n    types :\r\n        - input (start node)\r\n        - output (end node)\r\n        - default (node)\r\n        - smoothstep (edge)\r\n    */\r\n    function printNodes() {\r\n        let flow = reactFlowInstance.toObject();\r\n        let finalTree = {\r\n            entree: [],\r\n            sortie: [],\r\n            criteres: [],\r\n            methodes: [],\r\n            decisions: []\r\n        };\r\n        flow.elements.forEach(element => {\r\n            let transformedElement;\r\n            switch (element.type) {\r\n                case 'critereNode':\r\n                    transformedElement = transformToCritere(element);\r\n                    finalTree.criteres.push(transformedElement)\r\n                    break;\r\n                case 'default':\r\n                    transformedElement = transformToMethod(element, flow);\r\n                    finalTree.methodes.push(transformedElement)\r\n                    break;\r\n                case 'smoothstep':\r\n                    if(element.label){\r\n                        transformedElement = transformToDecision(element, flow);\r\n                        finalTree.decisions.push(transformedElement)\r\n                    }\r\n                        break;\r\n                case 'input':\r\n                    transformedElement = transformToEntree(element,flow);\r\n                    finalTree.entree.push(transformedElement)\r\n                    break;\r\n                case 'output':\r\n                    // transformedElement = transformToSortie(element);\r\n                    finalTree.sortie.push(element)\r\n                    break;\r\n            }\r\n        })\r\n        console.log(initialTree)\r\n        console.log(finalTree);\r\n    }\r\n\r\n    function transformToCritere(element){\r\n        let critere = {\r\n            ID_Critere: element.id,\r\n            Libelle: element.data.label,\r\n            x: element.position.x,\r\n            y: element.position.y\r\n        }\r\n        return critere;\r\n    }\r\n\r\n    function transformToMethod(element, flow){\r\n        let decision = flow.elements.find(el => el.type === \"smoothstep\" && el.target === element.id);\r\n        let method = {\r\n            ID_Method: element.id.slice(1),\r\n            ID_Decision: decision.id.slice(1),\r\n            Libelle: element.data.label,\r\n            x: element.position.x,\r\n            y: element.position.y\r\n        }\r\n        return method;\r\n    }\r\n\r\n    function transformToDecision(element, flow){\r\n        let outDecision;\r\n        if(element.target.includes(\"M\")){\r\n            outDecision = flow.elements.find(el => el.type === \"smoothstep\" && el.source === element.target);\r\n        }\r\n\r\n        let decision = {\r\n            ID_Decision: element.id.slice(1),\r\n            ID_Critere_entrant: element.source,\r\n            ID_Critere_sortant: (outDecision ? outDecision.target : element.target),\r\n            Libelle: element.label,\r\n        }\r\n        return decision;\r\n    }\r\n\r\n    function transformToEntree(element, flow){\r\n        let outDecision = flow.elements.find(el => el.type === \"smoothstep\" && el.source === element.id);\r\n\r\n        let critere = {\r\n            ID_Entree: element.id,\r\n            ID_Critere: outDecision.target,\r\n            x: element.position.x,\r\n            y: element.position.y\r\n        }\r\n        return critere;\r\n    }\r\n\r\n    function transformToSortie(element){\r\n        let critere = {\r\n            ID_Critere: element.id,\r\n            x: element.position.x,\r\n            y: element.position.y\r\n        }\r\n        return critere;\r\n    }\r\n\r\n    return (\r\n        <div className=\"Tree\">\r\n            {elements ?\r\n                <ReactFlowProvider>\r\n                    <div className=\"reactflow-wrapper\" ref={reactFlowWrapper}>\r\n                        <h1>Tree</h1>\r\n                        <div style={{height: 600, backgroundColor: 'lightgrey', margin: '100px'}}>\r\n                            <ReactFlow \r\n                                elements={elements}\r\n                                nodeTypes={nodeTypes}\r\n                                onElementsRemove={onElementsRemove}\r\n                                onConnect={onConnect}\r\n                                deleteKeyCode={46}\r\n                                onLoad={setReactFlowInstance}\r\n                                onDrop={onDrop}\r\n                                onDragOver={onDragOver}\r\n                                onElementClick={onElementClick}\r\n                                onPaneClick={onPaneClick}/>\r\n                        </div>\r\n                        <button onClick={() => printNodes()}>print nodes</button>\r\n                        <Toolbar/>\r\n                    </div>\r\n                </ReactFlowProvider>\r\n            : <Loader/> \r\n            }\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Tree;\r\n"]},"metadata":{},"sourceType":"module"}