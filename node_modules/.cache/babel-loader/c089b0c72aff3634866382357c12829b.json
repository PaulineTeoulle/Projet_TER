{"ast":null,"code":"'use strict'; // wrapper around mkdirp for tar's needs.\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = require('mkdirp');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst chownr = require('chownr');\n\nclass SymlinkError extends Error {\n  constructor(symlink, path) {\n    super('Cannot extract through symbolic link');\n    this.path = path;\n    this.symlink = symlink;\n  }\n\n  get name() {\n    return 'SylinkError';\n  }\n\n}\n\nclass CwdError extends Error {\n  constructor(path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'');\n    this.path = path;\n    this.code = code;\n  }\n\n  get name() {\n    return 'CwdError';\n  }\n\n}\n\nmodule.exports = (dir, opt, cb) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask;\n  const mode = opt.mode | 0o0700;\n  const needChmod = (mode & umask) !== 0;\n  const uid = opt.uid;\n  const gid = opt.gid;\n  const doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  const preserve = opt.preserve;\n  const unlink = opt.unlink;\n  const cache = opt.cache;\n  const cwd = opt.cwd;\n\n  const done = (er, created) => {\n    if (er) cb(er);else {\n      cache.set(dir, true);\n      if (created && doChown) chownr(created, uid, gid, er => done(er));else if (needChmod) fs.chmod(dir, mode, cb);else cb();\n    }\n  };\n\n  if (cache && cache.get(dir) === true) return done();\n\n  if (dir === cwd) {\n    return fs.stat(dir, (er, st) => {\n      if (er || !st.isDirectory()) er = new CwdError(dir, er && er.code || 'ENOTDIR');\n      done(er);\n    });\n  }\n\n  if (preserve) return mkdirp(dir, {\n    mode\n  }).then(made => done(null, made), done);\n  const sub = path.relative(cwd, dir);\n  const parts = sub.split(/\\/|\\\\/);\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);\n};\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length) return cb(null, created);\n  const p = parts.shift();\n  const part = base + '/' + p;\n  if (cache.get(part)) return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n};\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    if (er.path && path.dirname(er.path) === cwd && (er.code === 'ENOTDIR' || er.code === 'ENOENT')) return cb(new CwdError(cwd, er.code));\n    fs.lstat(part, (statEr, st) => {\n      if (statEr) cb(statEr);else if (st.isDirectory()) mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);else if (unlink) {\n        fs.unlink(part, er => {\n          if (er) return cb(er);\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n        });\n      } else if (st.isSymbolicLink()) return cb(new SymlinkError(part, part + '/' + parts.join('/')));else cb(er);\n    });\n  } else {\n    created = created || part;\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n  }\n};\n\nmodule.exports.sync = (dir, opt) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask;\n  const mode = opt.mode | 0o0700;\n  const needChmod = (mode & umask) !== 0;\n  const uid = opt.uid;\n  const gid = opt.gid;\n  const doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  const preserve = opt.preserve;\n  const unlink = opt.unlink;\n  const cache = opt.cache;\n  const cwd = opt.cwd;\n\n  const done = created => {\n    cache.set(dir, true);\n    if (created && doChown) chownr.sync(created, uid, gid);\n    if (needChmod) fs.chmodSync(dir, mode);\n  };\n\n  if (cache && cache.get(dir) === true) return done();\n\n  if (dir === cwd) {\n    let ok = false;\n    let code = 'ENOTDIR';\n\n    try {\n      ok = fs.statSync(dir).isDirectory();\n    } catch (er) {\n      code = er.code;\n    } finally {\n      if (!ok) throw new CwdError(dir, code);\n    }\n\n    done();\n    return;\n  }\n\n  if (preserve) return done(mkdirp.sync(dir, mode));\n  const sub = path.relative(cwd, dir);\n  const parts = sub.split(/\\/|\\\\/);\n  let created = null;\n\n  for (let p = parts.shift(), part = cwd; p && (part += '/' + p); p = parts.shift()) {\n    if (cache.get(part)) continue;\n\n    try {\n      fs.mkdirSync(part, mode);\n      created = created || part;\n      cache.set(part, true);\n    } catch (er) {\n      if (er.path && path.dirname(er.path) === cwd && (er.code === 'ENOTDIR' || er.code === 'ENOENT')) return new CwdError(cwd, er.code);\n      const st = fs.lstatSync(part);\n\n      if (st.isDirectory()) {\n        cache.set(part, true);\n        continue;\n      } else if (unlink) {\n        fs.unlinkSync(part);\n        fs.mkdirSync(part, mode);\n        created = created || part;\n        cache.set(part, true);\n        continue;\n      } else if (st.isSymbolicLink()) return new SymlinkError(part, part + '/' + parts.join('/'));\n    }\n  }\n\n  return done(created);\n};","map":{"version":3,"sources":["C:/wamp64/www/Projet_TER/node_modules/tar/lib/mkdir.js"],"names":["mkdirp","require","fs","path","chownr","SymlinkError","Error","constructor","symlink","name","CwdError","code","module","exports","dir","opt","cb","umask","mode","needChmod","uid","gid","doChown","processUid","processGid","preserve","unlink","cache","cwd","done","er","created","set","chmod","get","stat","st","isDirectory","then","made","sub","relative","parts","split","mkdir_","base","length","p","shift","part","mkdir","onmkdir","dirname","lstat","statEr","isSymbolicLink","join","sync","chmodSync","ok","statSync","mkdirSync","lstatSync","unlinkSync"],"mappings":"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","sourcesContent":["'use strict'\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = require('mkdirp')\nconst fs = require('fs')\nconst path = require('path')\nconst chownr = require('chownr')\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nmodule.exports = (dir, opt, cb) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = opt.cwd\n\n  const done = (er, created) => {\n    if (er)\n      cb(er)\n    else {\n      cache.set(dir, true)\n      if (created && doChown)\n        chownr(created, uid, gid, er => done(er))\n      else if (needChmod)\n        fs.chmod(dir, mode, cb)\n      else\n        cb()\n    }\n  }\n\n  if (cache && cache.get(dir) === true)\n    return done()\n\n  if (dir === cwd) {\n    return fs.stat(dir, (er, st) => {\n      if (er || !st.isDirectory())\n        er = new CwdError(dir, er && er.code || 'ENOTDIR')\n      done(er)\n    })\n  }\n\n  if (preserve)\n    return mkdirp(dir, {mode}).then(made => done(null, made), done)\n\n  const sub = path.relative(cwd, dir)\n  const parts = sub.split(/\\/|\\\\/)\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length)\n    return cb(null, created)\n  const p = parts.shift()\n  const part = base + '/' + p\n  if (cache.get(part))\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    if (er.path && path.dirname(er.path) === cwd &&\n        (er.code === 'ENOTDIR' || er.code === 'ENOENT'))\n      return cb(new CwdError(cwd, er.code))\n\n    fs.lstat(part, (statEr, st) => {\n      if (statEr)\n        cb(statEr)\n      else if (st.isDirectory())\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      else if (unlink) {\n        fs.unlink(part, er => {\n          if (er)\n            return cb(er)\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      } else if (st.isSymbolicLink())\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      else\n        cb(er)\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nmodule.exports.sync = (dir, opt) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = opt.cwd\n\n  const done = (created) => {\n    cache.set(dir, true)\n    if (created && doChown)\n      chownr.sync(created, uid, gid)\n    if (needChmod)\n      fs.chmodSync(dir, mode)\n  }\n\n  if (cache && cache.get(dir) === true)\n    return done()\n\n  if (dir === cwd) {\n    let ok = false\n    let code = 'ENOTDIR'\n    try {\n      ok = fs.statSync(dir).isDirectory()\n    } catch (er) {\n      code = er.code\n    } finally {\n      if (!ok)\n        throw new CwdError(dir, code)\n    }\n    done()\n    return\n  }\n\n  if (preserve)\n    return done(mkdirp.sync(dir, mode))\n\n  const sub = path.relative(cwd, dir)\n  const parts = sub.split(/\\/|\\\\/)\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n    p && (part += '/' + p);\n    p = parts.shift()) {\n    if (cache.get(part))\n      continue\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cache.set(part, true)\n    } catch (er) {\n      if (er.path && path.dirname(er.path) === cwd &&\n          (er.code === 'ENOTDIR' || er.code === 'ENOENT'))\n        return new CwdError(cwd, er.code)\n\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cache.set(part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cache.set(part, true)\n        continue\n      } else if (st.isSymbolicLink())\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n    }\n  }\n\n  return done(created)\n}\n"]},"metadata":{},"sourceType":"script"}